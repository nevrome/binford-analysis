---
output: 
  pdf_document:
    pandoc_args: [
      "-V", "classoption=twocolumn"
    ]
    toc: yes 
    fig_caption: yes
    latex_engine: xelatex
bibliography: bibliography.bib
mainfont: "Arial"
csl: deutsches-archaologisches-institut.csl
---

```{r global chunk options, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

```{r load libraries, echo=FALSE}
library(magrittr)
library(ggplot2)
# only magrittr and ggplot should be loaded here - everything else should be explicitly mentioned via package::function 
```

# Modelle zur Beschreibung der Ausbreitungsarealgröße von Jäger- und Sammlergruppen

## Problemstellung

Im 5. Kapitel "Designing Frames of Reference and Exploring Projections" beschreibt Binford unter anderem eine Methode, Vorhersagen zu Attributen von Jäger- und Sammlergruppen in globalem Maßstab auf Grundlage von ethnographischen und naturräumlichen Daten treffen und über Projektion auf Karten visualisieren zu können. Im Abschnitt "Projecting Hunter-Gatherer Populations to the Entire Earth" gibt es wiederrum einen Unterabschnitt "Using Relational Projections as Frames of Reference", der das Vorgehen anhand eines Beispiels illustriert. Binford schreibt: 

> If I can develop continously scaled equations that summarize the relationship between the properties of hunter-gatherer systems and suites of environmental variables, it is likely that these equations could be used to project estimates for habitats from which there are few, if any, actual cases of hunter-gatherers documented in the resent past. But since such equations summarize interactive ecological relationships that are not confined to particular time periods, they may furnish strong clues about hunter-gatherer organizational variability that will provide a strong platform for subsequent theory building.  
> 
> -- [@binford_constructing_2001, 154.]

Das Beispiel konzentiert sich auf die Variable AREA -- die Größe des Areals, das von einer Jäger- und Sammlergruppe relativ exklusiv genutzt wird gemessen in Vielfachen von 100km². Mittels multipler Regression auf Grundlage des Gruppendatensatzes kommt Binford zu folgender Gleichung \ref{eq:area_multi}, die die abhängige Variable AREA in Relation zu mehreren unabhängigen Variablen (siehe Tabelle \ref{tab:variable_description_1}) beschreibt:

\begin{equation} \label{eq:area_multi}
\begin{aligned}
\mathit{AREA} = & 10 \mathbin{\char`\^} [3.421431 + \\ 
                & (0.004732 * \mathit{HUNTING}) + \\
                & (-0.387229 * \mathit{LBIO5}) + \\
                & (0.186574 * \mathit{LCOKLM}) + \\
                & (-0.110286 * \mathit{LRUNOFF}) + \\
                & (0.175157 * \mathit{WATRGRC}) + \\
                & (-0.743144 * \mathit{PERWLTG}) + \\
                & (0.004706) * \mathit{RLOW} + \\
                & (-0.080339) * \mathit{RUNGRC} + \\
                & (0.024755 * \mathit{SDTEMP})]
\end{aligned}
\end{equation}

```{r table of variables in binfords model}
# create table data
tibble::tribble(
  ~colA,  ~colB, ~Einheit,
  "AREA", "Größe des Areals, das von einer Jäger- und Sammlergruppe relativ exklusiv genutzt wird", "100km²",
  "HUNTING", "Ernährungsanteil tierischer, terrestrischer Ressourcen", "%", 
  "LBIO5", "Primäre (pflanzliche) Biomasse", "log(kg/m^2)",
  "LCOKLM", "Distanz zur nächstgelegenen, marinen Küste", "log10(km)", 
  "LRUNOFF", "Wasser, das durch Abfluss für die Nutzung durch Pflanzen verloren geht, ", "log(mm)", 
  "WATRGRC", "Anzahl der Monate im Wachstumszeitraum, in denen Wasser im Boden gespeichert bleibt", "Anzahl", 
  "PERWLTG", "Anteil des Wachstumszeitraum in der die Wasserverfügbarkeit unter dem pflanzlichen Welkepunkt liegt", "%", 
  "RLOW", "Niederschlagsmenge im trockensten Monat des Jahres", "Millimeter", 
  "RUNGRC", "Anzahl der Monate im Wachstumszeitraum in denen der RUNOFF-Wert > 0", "Anzahl",
  "SDTEMP", "Standardabweichung der mittleren Monatstemperatur", "keine Einheit"
) %>%
  # table setup and settings
  knitr::kable(
    format = "latex",
    caption = "\\label{tab:variable_description_1}Kurzbeschreibung der Variablen in Binfords Ergebnismodell.",
    booktabs = T
  ) %>%
  kableExtra::column_spec(1, bold = TRUE) %>%
  kableExtra::column_spec(2, width = "13em")
```

Binford hat seine Analyse in SPSS (Version 6.1.2) ausgeführt. Ein Skriptprotokoll der Analysesession liegt mir nicht vor. Um die Ergebnis in Form der Modellgleichung zu reproduzieren, werde ich nun also zunächst versuchen, das Vorgehen so gut wie möglich nachzuvollziehen. Dafür steht mir eine hoffentlich gleiche oder zumindest hochgradig ähnliche Version des oben beschriebene Gruppendatensatz zu Verfügung. Ich weiß weiterhin, dass Binford sein Modell mittels der Methode schrittweiser, Multipler Regression ermittelt hat. Unabhängige Variablen, die sich kollinear zu anderen unabhägigen Variablen verhalten, hat er entfernt. Die abschließende Entscheidung über das beste Modell hat er unter Beachtung von den Indikatorgrößen $R^2$ und Standardfehler getroffen. 

## Datensatz

Ein wesentliches Wissendefizit besteht bezüglich der Information, in welcher Reihenfolge und mit welcher Rechtfertigung in den Schritten der Multiplen Regression Variablen entfernt wurden. Schon die Angabe welche Variablen im Ausgangsdatensatz berücksichtigt wurden ist unscharf. Immerhin: Da Multiple Regression nur auf Variablen der Intervall- oder Verhältnisskala (zusammen auch Kardinalskala oder metrisch skalierte Variablen) anwendbar ist, lässt sich eine erste Eingrenzung vornehmen. Der Metadatensatz LRBkey verfügt hierzu über die Spalte *type*, die zu jeder Variable ein Skalenniveau angibt. Leider wird nur zwischen "categorical" und "ordinal" unterschieden. Dabei werden alle Variablen jenseits der Nominalskala als "ordinal" angesprochen. Das genügt nicht, um automatisiert alle intervall- und verhältnisskalieren Variablen auszuwählen. Aus diesem Grund habe ich selbst die Spalte *type_exp* im Metadatensatz hinzugefügt, und nach meiner Einschätzung auf Grundlage des Wertebereichs und der Beschreibung eine Zuordnung zu einem der vier Skalenniveaus "nominal", "ordinal", "interval" und "ratio" vorgenommen. Tabelle \ref{tab:variable_key_example} illustriert die Unterschiede zwischen der vorhandenen und meiner neu vorgenommenen Zuordnung für ein paar zufällig ausgewählte Variablen. Abbildung \ref{fig:level_of_meas_bar} zeigt, wie sich die Reevaluation durch die in *type_exp* deutlich akzentuiertere Verteilung der Skalenniveaus auswirkt. 

```{r load binford data, cache=TRUE, message=FALSE, warning=FALSE}
# load data
# TODO: setup correct connections when all datasets are where they are supposed to be
key <- readr::read_csv("../data-raw/LRBkey.csv") #%>%
  #dplyr::rename("variable" = "X1")
main <- binford::LRB
```

```{r variable type example table, cache=TRUE}
# create random subset of key table
key[250:258, ] %>%
  # select showvars
  dplyr::select(variable, description, type, type_exp) %>%
  # add decorative ... at the beginning and end
  rbind(
    data.frame(variable = "...", description = "...", type = "...", type_exp= "..."), 
    .,
    data.frame(variable = "...", description = "...", type = "...", type_exp= "...")
  ) %>%
  # table setup and settings
  knitr::kable(
    format = "latex",
    caption = "\\label{tab:variable_key_example}Auszug aus der Metatabelle mit Variablenbeschreibungen und Skalenniveauklassifizierung in den Spalten \\textit{type} und \\textit{type\\_exp}.",
    booktabs = T
  ) %>%
  kableExtra::column_spec(1, bold = TRUE) %>%
  kableExtra::column_spec(2, width = "10em")
```

```{r type classification distribution plot, cache=TRUE, fig.cap="\\label{fig:level_of_meas_bar}Verteilung der Skalenniveauzuordung in den Variablen *type* und *type_exp* des Metatdatensatzes. *type_exp* habe ich hinzugefügt, um Variablen automatisiert nach ihrer Skalenniveauzuordnung auswählen zu können. Die Klassenzuordnung in *type* ist farblich auf *type_exp* abgetragen."}
# prepare factor levels of type_exp column
key$type_exp <- factor(
  key$type_exp, 
  levels =  c("nominal", "ordinal", "interval", "ratio", "unknown")
)

# barplot of count of type_exp
type_exp_bar <- key %>%
  ggplot(aes(x = type_exp, fill = type)) +
  geom_bar() + 
  theme_bw(base_size = 16) +
  scale_fill_manual(values = c("red", "black")) +
  ylab("") +
  guides(fill = FALSE) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1))

# prepare factor levels of type column
key$type <- factor(
  key$type,
  levels <- c("categorical", "ordinal")
)

# barplot of count of type
type_bar <- key %>%
  ggplot(aes(x = type, fill = type)) +
  geom_bar() +
  theme_bw(base_size = 16) +
  scale_fill_manual(values = c("red", "black")) +
  ylab("Anzahl der Variablen") +
  guides(fill = FALSE) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1))

# combine plots
cowplot::plot_grid(type_bar, type_exp_bar)
```

```{r apply selection, cache=TRUE}
# get interval and ratio variables 
inter_ratio_vars <- key %>%
  dplyr::filter(
    type_exp %in% c("interval", "ratio")
  ) %$%
  variable

# select only them for further analysis
sel1 <- main %>% 
  dplyr::select(dplyr::one_of(inter_ratio_vars))
```

Auf dieser Grundlage ist es jetzt also möglich, einen Ausgangsdatensatz zusammenstellen, der zwar alle `r nrow(sel1)` Gruppen aber nur die `r ncol(sel1)` interval- und ratioskalierten Variablen enthält. Hier fällt allerdings gleich ein erstes Defizit dieses Datensatzes auf: Einige Variablen haben sehr wenige Einträge, d.h. der Wert der entsprechenden Variable wurde nur bei wenigen Gruppen aufgenommen. Abbildung \ref{fig:is_na_bar} enthält ein Histogramm der Fehlstellenanzahl. 

```{r na histogram, fig.cap="\\label{fig:is_na_bar}Verteilung der Fehlstellenanzahl in metrisch skalierten Variablen und den zugehörigen Beobachtungen (Gruppen). Die Klassenbreite der Histogramme beträgt 15. Variablen und Gruppen ohne Fehlstellen wurden für die Visualisierung ausgeschlossen."}
# get data.frame with number of na per variable
na_pro_var <- sel1 %>% 
  purrr::map(
    ~sum(is.na(.))
  ) %>% 
  as.data.frame() %>% 
  tidyr::gather() %>%
  # remove variables with zero na
  dplyr::filter(
    value != 0
  )

# get data.frame with number of na per observation
na_pro_obs <- sel1 %>% t %>% as.data.frame() %>%
  purrr::map(
    ~sum(is.na(.))
  ) %>% 
  as.data.frame() %>% 
  tidyr::gather() %>%
  # remove variables with zero na
  dplyr::filter(
    value != 0
  )

# plot histogram for variables
na_vars_plot <- na_pro_var %>%
  ggplot(aes(x = value)) +
  geom_histogram(binwidth = 15, fill = "black") +
  theme_bw(base_size = 16) +
  ylab("Anzahl der Variablen") +
  xlab("Anzahl der Fehlstellen") +
  coord_flip() +
  xlim(-20, 340)

# plot histogramm for observations
na_obs_plot <- na_pro_obs %>%
  ggplot(aes(x = value)) +
  geom_histogram(binwidth = 15, fill = "black") +
  theme_bw(base_size = 16) +
  ylab("Anzahl der Gruppen") +
  xlab("") +
  coord_flip() +
  xlim(-20, 340)

# combine plots
cowplot::plot_grid(na_vars_plot, na_obs_plot)
```

```{r prepare na amounts}
# calculate proportions for text
without_na <- ncol(sel1) - nrow(na_pro_var)
without_na_percent <- round(without_na/ncol(sel1)*100)
```

Immerhin `r without_na` der `r ncol(sel1)` ($\approx$ `r without_na_percent`%) Variablen besitzen allerdings überhaupt keine Lehrstellen. Der Datensatz ist bemerkenswert vollständig. Bei den gruppenbezogenen Beobachtungen ist das Bild ausgeglichener: Für alle Gruppen liegt eine große Menge an Werten vor.

```{r}
# sel1 %>%
#   apply(
#     2,
#     function(x) {all(is.na(x))}
#   ) %>% any

# na_pro_var %>%
#   dplyr::filter(
#     value == nrow(sel1)
#   )

# sel2 <- sel1 %>%
#   dplyr::select(-female.kg)

```

## Multiple Regression

Multiple Lineare Regression ist ein Verfahren der Multivariaten Statistik, das die Erklärung und Vorhersage einer abhängigen Variable durch mehrere unabhängige Variablen erlaubt^[@backhaus_multivariate_2008, 52-53/64-65.]. Die Berechnung der Regressionsparameter funktioniert wie bei der Einfachen Regressionsanalyse durch Reduktion der Fehlerquadrate. Das Modellergebnis ist einerseits natürlich abhängig von den Eingabevariablen, andererseits aber auch -- zumindest wenn sie nicht vollständig unkorreliert sind -- von deren Eingabereihenfolge. Da im Fall der vorliegenden Analyse keine theoretischen oder sachlogischen Überlegungen Eingang finden sollen, die die Variablenauswahl determinieren würden, müssten eigentlich alle Permutationen von Auswahl und Reihenfolge betrachtet werden. Bei `r ncol(sel1) - 1` unabhängigen Variablen ist allerdings die Anzahl allein der Permutationen weit größer als praktisch in irgend einer Form verarbeitbar ($200! \approx 7.887*10^{374}$). Aus diesem Grund muss auf das Verfahren der Schrittweisen Regressionsanalyse zurückgegriffen werden, das mittels Prüfgrößen selbständig und in verhältnismäßig wenigen Iterationsschritten eine Variablenauswahl trifft^[@backhaus_multivariate_2008, 100-105.].  


```{r}
# model <- lm(area ~ ., data = sel1)
# 
# MASS::stepAIC()
```




